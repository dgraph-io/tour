+++
date = "2017-04-27T23:05:50+10:00"
next = "/graphqlschema/5"
prev = "/graphqlschema/3"
title = "Reverse edges"
weight = 4
course = 3
courseName = "Schema"
type = "graphql/schema"
+++

In Dgraph, edges are directional. A query cannot traverse an edge in reverse.
Two options exist for querying in both directions:

- Add the reverse edge to the schema and then add all the reverse edge data.
- Tell Dgraph to always store the reverse edge using the `@reverse` keyword in
  the DQL schema. (**Not available in the GraphQL schema**)

Dgraph's generated GraphQL API supports the first option through the
`@hasInverse` directive. Instead of manually creating two edges for each
bidirectional relationship, you apply `@hasInverse` and the API keeps both
directions balanced on every create or delete. You need only apply the directive
to one end of the relationship, but applying it to both ends improves
readability. `@hasInverse` behaves the same whether applied to one side, the
other, or both.

You already used this directive in the previous lessons, applying `@hasInverse`
to these relationships:

- `Person.friends` <-> `Person.friends`
- `Person.ownsPets` <-> `Animal.owner`
- `Person.employers` <-> `Company.employees`
- `Person.manages` <-> `Person.manager`

The `@hasInverse` directive requires you to define the field on the opposite side
of the edge.

Here is a simple schema that uses `@hasInverse` to create a bidirectional edge
between `Person.employers` and `Company.employees`:

```
type Company {
  employees: [Person] @hasInverse(field: "employers")
}
type Person {
  employers: [Company]
}
```

Bidirectional edges support three relationship cardinalities: one-to-one (`1:1`),
one-to-many (`1:n`), and many-to-many (`n:n`).

To define a `1:1` relationship, omit list brackets on both sides. Each node then
points to at most one node on the opposite side of the edge.

```
type Person {
  office: Office
}
type Office {
  person: Person @hasInverse(field: "office")
}
```

To define a one-to-many (`1:n`) relationship, wrap the "many" side of the
relationship in a list. The following example shows that an `Office` belongs to
one `Company`, but a single Company can have many offices.

```
type Company {
  offices: [Office] @hasInverse(field: "company")
}
type Office {
  company: Company
}
```

To define a many-to-many (`n:n`) relationship, wrap both sides in a list. The
following example shows that a `Person` has many roles, and a `Role` belongs to
many people.

```
type Person {
  roles: [Role]
}
type Role {
  people: [Person] @hasInverse(field: "roles")
}
```

One-to-one and many-to-many relationships can point to the same type. The social
graph schema demonstrated this with `Person` having multiple friends:

```
type Person {
  friends: [Person] @hasInverse(field: "friends")
}
```

You can iterate on your schema to add or remove bidirectional edges. Removing one
side of a two-way relationship preserves all functionality and data for the
remaining single-edge relationship.

The GraphQL API keeps `@hasInverse` edges balanced, but edges can fall
out-of-sync when you change the schema or bypass the GraphQL API to access other
Dgraph endpoints. A community member posted
[a script to repair unbalanced inverse relationships](https://discuss.dgraph.io/t/fixing-inverse-relationships/12888).

**Something to try**: Add a relationship from a `Company` to its mascot `Animal`,
and add the inverse relationship from `Animal` to the companies it represents.

{{% expandable %}}

```
type Company {
  ...
  mascot: Animal @hasInverse(field: "represents") # hasInverse is only required on one of these edges
}
type Animal {
  ...
  represents: [Company] @hasInverse(field: "mascot") # hasInverse is only required on one of these edges
}
```

{{% /expandable %}}
