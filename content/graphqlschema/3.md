+++
date = "2017-04-27T23:05:50+10:00"
next = "/graphqlschema/4"
prev = "/graphqlschema/2"
title = "Node Identifiers"
weight = 3
course = 3
courseName = "Schema"
type = "graphql/schema"
+++

The previous lesson showed that the `Company` type lacks a unique identifier,
preventing you from running a `getCompany` query or referencing a specific
company to create edges to pre-existing nodes.

From the GraphQL API perspective this was true, but every node already has a
unique identifier (UID) via the ID scalar, even when that identifier is not
mapped to a field in the GraphQL schema. No two nodes share the same UID,
regardless of type.

This schema update also adds a `hash` search directive to the Company's name and
expands the search directive on the Company's industry to include both `hash` and
`term` indexes.

After you push this change, the `id` field becomes available on queried companies,
already populated with the appropriate node UID.

**Something to try**: After pushing this schema update, go back to the previous
lesson using the **Back** button to find a query runner, and then try to query
the `Company` type to see IDs.

{{% expandable %}}

```
{
  queryCompany {
    id
    name
    industry
    managers: employees(filter: { has: manages }) {
      id
      name
      employees: manages {
        id
        name
      }
    }
  }
}
```

{{% /expandable %}}

**For a bigger challenge**: Go back to the previous lesson for a query runner,
and then try to mutate Alice (`xid`: "alice") and update the `Person` to link to an
existing `Company` as her employer.

{{% expandable %}}

```
mutation {
  updatePerson(input: {
    filter: { xid: { eq: "alice" } }
    set: { employers: [{ id: "<UID here>" }] }
  }) {
    person {
      xid
      name
      employers {
        id
        name
        employees {
          name
        }
      }
    }
  }
}
```

If you use the ID of a `Company` with existing employees, the response returns
all employees, not just Alice. {{% /expandable %}}
