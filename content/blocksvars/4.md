+++
date = "2017-05-01T20:48:27+10:00"
next = "/blocksvars/5"
prev = "/blocksvars/3"
title = "Query Variables in another query block I"
weight = 4
course = 5
courseName = "Var Blocks"
+++

In the previous query, the variable `JC_actor` evaluated to all actors in any
Jane Campion film. No matter where you use it, it contains the full set.

This is the key to using Dgraph variables correctly: a variable is global. It
evaluates to every node that matches the defining edge across the entire query.
It does not re-evaluate per parent -- `JC_actor` yields the same UID list
whether used inside a single Jane Campion film or elsewhere.

We can also use query variables in another query block, both as the nodes the
root filter matches and in internal filters.

Peter Jackson often appears in his own films, mostly in the background
or just a glimpse, but he's there. The query shows all films that Peter Jackson
has both directed and appeared in.

Explaining the query:

The first block finds every node whose name contains both "Peter" and "Jackson".
Without `@cascade`, this block could return homonyms such as "Sam Peter Jackson".
Because the block also traverses `director.film`, `@cascade` drops any node that
lacks that edge -- so only a "Peter Jackson" who directed at least one film
survives. In our dataset, exactly one Peter Jackson is a director.

The second block reuses that result (a single UID). `@cascade` here enforces
two additional constraints: Peter Jackson must appear as an actor on the film,
and each film must have a `name@en` predicate. Any film that fails either
constraint is excluded from the results.
