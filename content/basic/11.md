+++
date = "2017-05-01T11:55:43+10:00"
next = "/basic/12"
prev = "/basic/10"
title = "How Dgraph Search Works"
weight = 11
course = 2
courseName = "Basic"


+++

Every query begins at a root node.

Dgraph graphs can contain millions of nodes, so each query must start from a
narrow entry point. The `func:` keyword and a search function select that
initial set of root nodes.

The examples so far have used `eq` and `allofterms` for string search, but
`func:` also supports dates, numbers, and filters on `count`.

Dgraph requires an index on any value searched this way. An index lets Dgraph
jump straight to matching values instead of scanning the entire database.

From the root set, Dgraph follows edges to satisfy the rest of the query.
Filters inside nested blocks apply only to nodes reached by following those
edges, never to the root set itself.

The root `func:` accepts a single function. To combine conditions, add an
`@filter` with `AND`, `OR`, or `NOT` connectives using the syntax
`query_name(func: foo(...)) @filter(... AND ...) {...}`.

Try this: find all people in their 20s who have at least 2 friends. 

{{% expandable %}}

```
{
  lots_of_friends(func: ge(count(friend), 2)) @filter(ge(age, 20) AND lt(age, 30)) {
    name@.
    age
    friend {
        name@.
    }
  }
}
```

{{% /expandable %}}
